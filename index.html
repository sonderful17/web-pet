<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WEB PET</title>
<style>
  @font-face {
    font-family: 'Pixel';
    src: local('Courier New'), local('Courier'), local('monospace');
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'Courier New', Courier, monospace;
    overflow: hidden;
  }

  /* CRT Monitor Frame */
  #monitor {
    position: relative;
    width: 480px;
    background: #0a0a0a;
    border: 4px solid #1a3a1a;
    border-radius: 8px;
    box-shadow:
      0 0 20px rgba(0, 255, 0, 0.1),
      inset 0 0 60px rgba(0, 0, 0, 0.5);
    overflow: hidden;
  }

  /* CRT Scanline Overlay */
  #monitor::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.15) 2px,
      rgba(0, 0, 0, 0.15) 4px
    );
    pointer-events: none;
    z-index: 100;
  }

  /* CRT Flicker */
  @keyframes flicker {
    0% { opacity: 0.97; }
    5% { opacity: 0.95; }
    10% { opacity: 0.98; }
    50% { opacity: 0.96; }
    100% { opacity: 0.97; }
  }

  #screen {
    padding: 16px;
    animation: flicker 0.15s infinite;
    color: #33ff33;
    font-size: 14px;
    line-height: 1.4;
    text-shadow: 0 0 5px rgba(51, 255, 51, 0.5);
    min-height: 640px;
    display: flex;
    flex-direction: column;
  }

  /* Blinking cursor */
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }

  .cursor {
    display: inline-block;
    animation: blink 1s step-end infinite;
  }

  .screen-section {
    border-top: 2px solid #1a5a1a;
    border-bottom: 2px solid #1a5a1a;
    padding: 8px 0;
    margin: 4px 0;
  }

  /* Title */
  .title {
    text-align: center;
    font-size: 22px;
    letter-spacing: 8px;
    padding: 12px 0;
    border-bottom: 2px double #1a5a1a;
    text-shadow: 0 0 10px rgba(51, 255, 51, 0.8);
  }

  /* Naming Screen */
  #naming-screen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1;
    gap: 20px;
  }

  #naming-screen .prompt {
    font-size: 14px;
    text-align: center;
  }

  #name-input {
    background: transparent;
    border: 2px solid #33ff33;
    color: #33ff33;
    font-family: 'Courier New', Courier, monospace;
    font-size: 18px;
    padding: 8px 12px;
    text-align: center;
    outline: none;
    width: 240px;
    text-shadow: 0 0 5px rgba(51, 255, 51, 0.5);
  }

  #name-input::placeholder {
    color: #1a5a1a;
  }

  #name-input:focus {
    box-shadow: 0 0 10px rgba(51, 255, 51, 0.3);
  }

  .btn {
    background: transparent;
    border: 2px solid #33ff33;
    color: #33ff33;
    font-family: 'Courier New', Courier, monospace;
    font-size: 14px;
    padding: 8px 20px;
    cursor: pointer;
    text-shadow: 0 0 5px rgba(51, 255, 51, 0.5);
    transition: all 0.1s;
    position: relative;
  }

  .btn:hover:not(:disabled) {
    background: #33ff33;
    color: #000;
    text-shadow: none;
    box-shadow: 0 0 15px rgba(51, 255, 51, 0.5);
  }

  .btn:active:not(:disabled) {
    transform: scale(0.95);
  }

  .btn:disabled {
    border-color: #1a3a1a;
    color: #1a3a1a;
    cursor: not-allowed;
    text-shadow: none;
  }

  .btn .cooldown-text {
    font-size: 11px;
  }

  /* Game Screen */
  #game-screen {
    display: none;
    flex-direction: column;
    flex: 1;
    position: relative;
  }

  /* Info Panel */
  .info-panel {
    padding: 8px 4px;
  }

  .info-panel .pet-name-line {
    font-size: 16px;
    margin-bottom: 4px;
  }

  .info-line {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    padding: 1px 0;
  }

  .status-display {
    font-size: 15px;
    font-weight: bold;
    text-align: center;
    padding: 4px 0;
    letter-spacing: 3px;
  }

  .status-thriving { color: #33ff33; }
  .status-alive { color: #33ff33; }
  .status-surviving { color: #cccc33; text-shadow: 0 0 5px rgba(204, 204, 51, 0.5); }
  .status-dying { color: #ff9933; text-shadow: 0 0 5px rgba(255, 153, 51, 0.5); }
  .status-barely-alive { color: #ff3333; text-shadow: 0 0 5px rgba(255, 51, 51, 0.5); }
  .status-dead { color: #660000; text-shadow: 0 0 5px rgba(102, 0, 0, 0.5); }

  /* Pet Display Area */
  .pet-area {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 200px;
    position: relative;
    overflow: hidden;
    cursor: pointer;
  }

  #pet-sprite {
    position: relative;
    transition: transform 0.3s;
  }

  /* Animation classes */
  @keyframes chomp {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1.1, 0.9); }
    50% { transform: scale(0.9, 1.1); }
    75% { transform: scale(1.05, 0.95); }
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    25% { transform: translateY(-20px); }
    50% { transform: translateY(0); }
    75% { transform: translateY(-12px); }
  }

  @keyframes sleepSink {
    0% { transform: translateY(0); }
    100% { transform: translateY(8px); }
  }

  .anim-feed { animation: chomp 0.25s ease-in-out 4; }
  .anim-play { animation: bounce 0.375s ease-in-out 4; }
  .anim-sleep { animation: sleepSink 2s ease-in-out forwards; }

  /* Evolution event */
  @keyframes evolveFlash {
    0%, 100% { opacity: 0; }
    10%, 90% { opacity: 1; }
  }

  @keyframes evolvePulse {
    0%, 100% { transform: scale(1); text-shadow: 0 0 10px rgba(51, 255, 51, 0.8); }
    50% { transform: scale(1.1); text-shadow: 0 0 20px rgba(51, 255, 51, 1); }
  }

  .evolve-overlay {
    position: absolute;
    inset: 0;
    background: rgba(51, 255, 51, 0.15);
    z-index: 20;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    animation: evolveFlash 3s ease-in-out forwards;
    pointer-events: none;
  }

  .evolve-text {
    font-family: 'Courier New', Courier, monospace;
    font-size: 18px;
    color: #33ff33;
    letter-spacing: 4px;
    animation: evolvePulse 0.5s ease-in-out 6;
    text-shadow: 0 0 10px rgba(51, 255, 51, 0.8);
  }

  .evolve-stage {
    font-family: 'Courier New', Courier, monospace;
    font-size: 14px;
    color: #66ff66;
    margin-top: 8px;
    letter-spacing: 2px;
  }

  /* Random event overlay */
  @keyframes eventFlash {
    0%, 100% { opacity: 0; }
    8%, 85% { opacity: 1; }
  }

  @keyframes eventShake {
    0%, 100% { transform: translateX(0); }
    15% { transform: translateX(-3px); }
    30% { transform: translateX(3px); }
    45% { transform: translateX(-2px); }
    60% { transform: translateX(2px); }
    75% { transform: translateX(0); }
  }

  .event-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.75);
    z-index: 20;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    animation: eventFlash 3.5s ease-in-out forwards;
    pointer-events: none;
  }

  .event-overlay.event-fatal {
    background: rgba(40, 0, 0, 0.8);
    animation: eventFlash 3.5s ease-in-out forwards, eventShake 0.5s ease-in-out 3;
  }

  .event-title {
    font-family: 'Courier New', Courier, monospace;
    font-size: 16px;
    color: #33ff33;
    letter-spacing: 3px;
    text-shadow: 0 0 10px rgba(51, 255, 51, 0.8);
  }

  .event-fatal .event-title {
    color: #ff3333;
    text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
  }

  .event-msg {
    font-family: 'Courier New', Courier, monospace;
    font-size: 12px;
    color: #66ff66;
    margin-top: 6px;
    letter-spacing: 1px;
    text-align: center;
    padding: 0 10px;
  }

  .event-fatal .event-msg {
    color: #ff6666;
  }

  /* Friend sprite for MADE A FRIEND event */
  @keyframes friendWalkLeft {
    0%   { transform: translateX(120px) scaleX(-1); opacity: 0; }
    15%  { opacity: 1; }
    85%  { opacity: 1; }
    100% { transform: translateX(-120px) scaleX(-1); opacity: 0; }
  }

  .friend-sprite {
    position: absolute;
    bottom: 20px;
    left: 50%;
    animation: friendWalkLeft 3.5s ease-in-out forwards;
    pointer-events: none;
  }

  /* Floating food pixel */
  @keyframes foodDrop {
    0% { transform: translateY(-60px); opacity: 1; }
    80% { transform: translateY(0px); opacity: 1; }
    100% { transform: translateY(0px); opacity: 0; }
  }

  .food-particle {
    position: absolute;
    width: 6px;
    height: 6px;
    background: #33ff33;
    box-shadow:
      6px 0 0 #33ff33,
      0 6px 0 #33ff33,
      6px 6px 0 #33ff33,
      12px 0 0 #33ff33,
      12px 6px 0 #33ff33;
    animation: foodDrop 1s ease-in forwards;
    z-index: 10;
  }

  /* Sparkle for play */
  @keyframes sparkle {
    0% { transform: scale(0) rotate(0deg); opacity: 1; }
    50% { transform: scale(1) rotate(180deg); opacity: 1; }
    100% { transform: scale(0) rotate(360deg); opacity: 0; }
  }

  .sparkle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #33ff33;
    box-shadow:
      -4px 0 0 #33ff33,
      4px 0 0 #33ff33,
      0 -4px 0 #33ff33,
      0 4px 0 #33ff33;
    animation: sparkle 0.75s ease-out forwards;
    z-index: 10;
  }

  /* Sleep Z's */
  @keyframes floatZ {
    0% { transform: translateY(0) translateX(0); opacity: 1; }
    100% { transform: translateY(-50px) translateX(15px); opacity: 0; }
  }

  .sleep-z {
    position: absolute;
    font-size: 16px;
    color: #33ff33;
    text-shadow: 0 0 5px rgba(51, 255, 51, 0.5);
    animation: floatZ 2s ease-out forwards;
    z-index: 10;
    font-family: 'Courier New', Courier, monospace;
  }

  /* Stat Bars */
  .stats-panel {
    padding: 8px 4px;
  }

  .stat-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 3px 0;
    font-size: 13px;
  }

  .stat-label {
    width: 32px;
    flex-shrink: 0;
  }

  .stat-bar-container {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 2px;
    font-size: 13px;
  }

  .stat-bar {
    display: flex;
    gap: 1px;
  }

  .stat-block {
    width: 8px;
    height: 12px;
    border: 1px solid #1a3a1a;
  }

  .stat-block.filled {
    background: #33ff33;
    border-color: #33ff33;
    box-shadow: 0 0 3px rgba(51, 255, 51, 0.3);
  }

  .stat-block.empty {
    background: transparent;
  }

  .stat-value {
    width: 30px;
    text-align: right;
    flex-shrink: 0;
  }

  /* Action Buttons */
  .actions-panel {
    display: flex;
    justify-content: center;
    gap: 8px;
    padding: 12px 0;
    border-top: 2px solid #1a5a1a;
    margin-top: auto;
  }

  .action-btn {
    min-width: 80px;
    padding: 8px 14px;
    text-align: center;
  }

  /* Death Screen */
  #death-screen {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1;
    gap: 16px;
  }

  .death-text {
    font-size: 20px;
    color: #660000;
    text-shadow: 0 0 10px rgba(102, 0, 0, 0.5);
    letter-spacing: 4px;
  }

  .death-name {
    font-size: 16px;
    color: #993333;
  }

  .death-stats {
    font-size: 12px;
    color: #1a5a1a;
    text-align: center;
    line-height: 1.6;
  }

  /* Idle breathing animation */
  @keyframes breathe {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-3px); }
  }

  .idle-anim {
    animation: breathe 2s ease-in-out infinite;
  }

  /* Pixel art sprite rendering */
  .pixel-sprite {
    image-rendering: pixelated;
  }

  /* Hide screens */
  .hidden { display: none !important; }
  .flex { display: flex !important; }

  /* Leaderboard Button Row */
  .leaderboard-btn-row {
    display: flex;
    justify-content: center;
    padding: 8px 0 0 0;
  }

  .btn-kill {
    border-color: #660000;
    color: #ff3333;
    text-shadow: 0 0 5px rgba(255, 51, 51, 0.5);
  }
  .btn-kill:hover {
    background: rgba(255, 0, 0, 0.15);
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.3), inset 0 0 10px rgba(255, 0, 0, 0.1);
  }

  .kill-confirm {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.85);
    z-index: 30;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .kill-confirm-box {
    text-align: center;
    padding: 20px;
  }

  .kill-confirm-title {
    font-size: 20px;
    color: #ff3333;
    letter-spacing: 4px;
    text-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
    margin-bottom: 12px;
  }

  .kill-confirm-msg {
    font-size: 12px;
    color: #993333;
    margin-bottom: 20px;
    line-height: 1.6;
  }

  .kill-confirm-btns {
    display: flex;
    gap: 12px;
    justify-content: center;
  }

  /* Leaderboard Overlay */
  #leaderboard-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.92);
    z-index: 50;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 16px;
  }

  .leaderboard-panel {
    width: 100%;
    max-width: 420px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .leaderboard-title {
    text-align: center;
    font-size: 18px;
    letter-spacing: 4px;
    color: #33ff33;
    text-shadow: 0 0 10px rgba(51, 255, 51, 0.8);
    padding-bottom: 8px;
    border-bottom: 2px double #1a5a1a;
  }

  .leaderboard-tabs {
    display: flex;
    justify-content: center;
    gap: 8px;
  }

  .lb-tab {
    min-width: 100px;
    text-align: center;
    font-size: 12px;
    padding: 6px 16px;
  }

  .lb-tab.active {
    background: #33ff33;
    color: #000;
    text-shadow: none;
    box-shadow: 0 0 15px rgba(51, 255, 51, 0.5);
  }

  .leaderboard-list {
    min-height: 180px;
  }

  .lb-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 4px;
    border-bottom: 1px solid #1a3a1a;
    font-size: 13px;
    color: #33aa33;
  }

  .lb-row.lb-header {
    color: #1a5a1a;
    font-size: 11px;
    border-bottom: 1px solid #1a5a1a;
  }

  .lb-rank {
    width: 28px;
    text-align: center;
    flex-shrink: 0;
  }

  .lb-name {
    flex: 1;
    padding: 0 8px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .lb-value {
    width: 70px;
    text-align: right;
    flex-shrink: 0;
  }

  .lb-row.lb-live {
    color: #66ff66;
    text-shadow: 0 0 8px rgba(51, 255, 51, 0.6);
  }

  .lb-live-marker {
    font-size: 11px;
    color: #33ff33;
  }

  .lb-dead-marker {
    font-size: 11px;
    color: #993333;
    margin-left: 4px;
  }

  .lb-empty {
    text-align: center;
    color: #1a5a1a;
    padding: 30px 0;
    font-size: 12px;
  }

  .lb-close {
    align-self: center;
    margin-top: 8px;
  }
</style>
</head>
<body>
<div id="monitor">
  <div id="screen">
    <div class="title">W E B &nbsp; P E T</div>

    <!-- Naming Screen -->
    <div id="naming-screen">
      <div class="prompt">
        INITIALISING NEW PET UNIT...<br><br>
        ENTER DESIGNATION:
      </div>
      <input type="text" id="name-input" placeholder="NAME YOUR PET" maxlength="12" autocomplete="off" spellcheck="false">
      <button class="btn" id="name-submit" onclick="createPet()">[ ACTIVATE ]</button>
    </div>

    <!-- Game Screen -->
    <div id="game-screen">
      <div class="info-panel screen-section">
        <div class="pet-name-line" id="pet-name-line"></div>
        <div class="info-line">
          <span id="stage-display"></span>
          <span id="day-display"></span>
        </div>
        <div class="info-line">
          <span id="weight-display"></span>
          <span id="type-display"></span>
        </div>
        <div class="status-display" id="status-display"></div>
      </div>

      <div class="pet-area screen-section" id="pet-area">
        <div id="pet-sprite" class="idle-anim"></div>
      </div>

      <div class="stats-panel screen-section">
        <div class="stat-row">
          <span class="stat-label">HP</span>
          <div class="stat-bar-container">
            <span>[</span>
            <div class="stat-bar" id="bar-health"></div>
            <span>]</span>
          </div>
          <span class="stat-value" id="val-health"></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">HNG</span>
          <div class="stat-bar-container">
            <span>[</span>
            <div class="stat-bar" id="bar-hunger"></div>
            <span>]</span>
          </div>
          <span class="stat-value" id="val-hunger"></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">NRG</span>
          <div class="stat-bar-container">
            <span>[</span>
            <div class="stat-bar" id="bar-energy"></div>
            <span>]</span>
          </div>
          <span class="stat-value" id="val-energy"></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">HPY</span>
          <div class="stat-bar-container">
            <span>[</span>
            <div class="stat-bar" id="bar-happiness"></div>
            <span>]</span>
          </div>
          <span class="stat-value" id="val-happiness"></span>
        </div>
      </div>

      <div class="actions-panel">
        <button class="btn action-btn" id="btn-feed" onclick="doAction('feed')">[ FEED ]</button>
        <button class="btn action-btn" id="btn-play" onclick="doAction('play')">[ PLAY ]</button>
        <button class="btn action-btn" id="btn-sleep" onclick="doAction('sleep')">[ SLEEP ]</button>
      </div>
      <div class="leaderboard-btn-row">
        <button class="btn" onclick="openLeaderboard()">[ LEADERBOARD ]</button>
      </div>
      <div class="leaderboard-btn-row">
        <button class="btn btn-kill" onclick="confirmKill()">[ TERMINATE ]</button>
      </div>

      <!-- Kill confirmation overlay -->
      <div id="kill-confirm" class="kill-confirm hidden">
        <div class="kill-confirm-box">
          <div class="kill-confirm-title">WARNING</div>
          <div class="kill-confirm-msg">This will permanently terminate your pet.<br>This action is irreversible.</div>
          <div class="kill-confirm-btns">
            <button class="btn btn-kill" onclick="executeKill()">[ CONFIRM ]</button>
            <button class="btn" onclick="cancelKill()">[ CANCEL ]</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Death Screen -->
    <div id="death-screen">
      <div class="death-text">R . I . P .</div>
      <div class="death-name" id="death-name"></div>
      <div id="death-sprite"></div>
      <div class="death-stats" id="death-stats"></div>
      <button class="btn" onclick="resetPet()">[ NEW PET ]</button>
      <button class="btn" onclick="openLeaderboard()">[ LEADERBOARD ]</button>
    </div>
  </div>

  <!-- Leaderboard Overlay -->
  <div id="leaderboard-overlay" class="hidden">
    <div class="leaderboard-panel">
      <div class="leaderboard-title">LEADERBOARD</div>
      <div class="leaderboard-tabs">
        <button class="btn lb-tab active" data-sort="days" onclick="switchLeaderboardTab('days')">[ DAYS ]</button>
        <button class="btn lb-tab" data-sort="weight" onclick="switchLeaderboardTab('weight')">[ WEIGHT ]</button>
      </div>
      <div class="leaderboard-list" id="leaderboard-list"></div>
      <button class="btn lb-close" onclick="closeLeaderboard()">[ CLOSE ]</button>
    </div>
  </div>
</div>

<!-- Firebase SDK (compat) -->
<script src="https://www.gstatic.com/firebasejs/12.9.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.9.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore-compat.js"></script>

<script>
// ============================================================
// CONSTANTS
// ============================================================
const SAVE_KEY = 'webpet_save';
const LEADERBOARD_KEY = 'webpet_leaderboard';

// FIREBASE CONFIG — Replace with your Firebase project config
// https://console.firebase.google.com → Project Settings → Your Apps → Web
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyAIdyOh9-37f6_SykAL8w6Dz4wUerfrXfY",
  authDomain: "web-pets-c2d1f.firebaseapp.com",
  projectId: "web-pets-c2d1f",
  storageBucket: "web-pets-c2d1f.firebasestorage.app",
  messagingSenderId: "1004332017761",
  appId: "1:1004332017761:web:33bf7faa0659e4f11fa220"
};
const DECAY_INTERVAL = 30000;        // 30s between stat ticks while open
const AWAY_DECAY_RATE = 1 / 1200;     // 1 point per 20 min (1200s) while away
const AWAY_STAT_FLOOR = 10;          // stats won't go below this from away-decay
const AUTOSAVE_INTERVAL = 10000;     // save every 10s
const PIXEL_SIZE = 6;                // size of each pixel in sprites

const COOLDOWNS = { feed: 15000, play: 5000, sleep: 40000 };

const ACTION_EFFECTS = {
  feed:  { hunger: 20, happiness: 15,  health: 15,  energy: 5,  weight: 0.5 },
  play:  { hunger: -10, happiness: 25, health: -5, energy: -15, weight: -0.2 },
  sleep: { hunger: -5,  happiness: 15,  health: 30, energy: 50,  weight: 0.1 }
};

// Random events: fires at random intervals between min and max ms
// Each event has a weight (relative probability), stat effects, weight effect,
// and an optional `fatal` flag that instantly kills the pet.
const RANDOM_EVENT_MIN_DELAY = 10000;  // earliest: 10s
const RANDOM_EVENT_MAX_DELAY = 60000;  // latest: 1min

const RANDOM_EVENTS = [
  // Positive events
  { name: 'CRASHED A WEDDING',       msg: 'ate, drank and was merry!',        weight: 2, effects: { hunger: 30, happiness: 20, health: 10, energy: -5 },   weightDelta: 15.0 },
  { name: 'GOOD DREAM',        msg: 'had a wonderful dream!',              weight: 3, effects: { hunger: 20, happiness: 25, health: 15, energy: 20 },   weightDelta: 5.0 },
  { name: 'SUNSHINE',           msg: 'basked in warm sunshine!',            weight: 3, effects: { hunger: -25, happiness: 30, health: 20, energy: -15 }, weightDelta: 5.0 },
  { name: 'GROWTH SPURT',      msg: 'had a growth spurt!',                 weight: 2, effects: { hunger: -25, happiness: 5, health: 0, energy: -20 }, weightDelta: 32.0 },
  { name: 'MADE A FRIEND',     msg: 'made a new friend!',                  weight: 3, effects: { hunger: 0, happiness: 30, health: 15, energy: -5 },   weightDelta: 5.0 },
  // Negative events
  { name: 'BAD FOOD',          msg: 'ate something bad!',                  weight: 3, effects: { hunger: 20, happiness: -30, health: -20, energy: -25 }, weightDelta: -2.0 },
  { name: 'NIGHTMARE',         msg: 'had a terrible nightmare!',           weight: 3, effects: { hunger: 0, happiness: -30, health: -5, energy: -15 }, weightDelta: 0 },
  { name: 'GOT LOST',          msg: 'got lost and wandered around!',       weight: 2, effects: { hunger: -15, happiness: -15, health: -5, energy: -20 }, weightDelta: 0 },
  { name: 'COLD SNAP',         msg: 'caught a chill!',                     weight: 3, effects: { hunger: -10, happiness: -10, health: -15, energy: -10 }, weightDelta: 0 },
  { name: 'PARASITE',          msg: 'picked up a parasite!',               weight: 1, effects: { hunger: -20, happiness: -15, health: -35, energy: -10 }, weightDelta: -2.0 },
  // Fatal events (rare)
  { name: 'LIGHTNING STRIKE',  msg: 'was struck by lightning!',            weight: 0.5, effects: { hunger: 0, happiness: -100, health: -80, energy: -80 }, weightDelta: -5.0 },
  { name: 'EATEN BY PREDATOR', msg: 'was eaten by a predator!',           weight: 0.5, effects: {}, fatal: true },
  { name: 'FELL OFF A CLIFF',  msg: 'fell off a cliff!',                  weight: 1, effects: { hunger: 0, happiness: -100, health: -80, energy: -80 }, weightDelta: -5.0 },
];

const STATUS_THRESHOLDS = [
  { min: 80, label: 'THRIVING',     cls: 'status-thriving' },
  { min: 60, label: 'ALIVE',        cls: 'status-alive' },
  { min: 40, label: 'SURVIVING',    cls: 'status-surviving' },
  { min: 20, label: 'DYING',        cls: 'status-dying' },
  { min: 5,  label: 'HANGING ON BY A THREAD', cls: 'status-barely-alive' },
  { min: 0,  label: 'DEAD',         cls: 'status-dead' }
];

const EVOLUTION_STAGES = [
  { name: 'ELDER', minDays: 14, minWeight: 128 },
  { name: 'ADULT', minDays: 7,  minWeight: 64 },
  { name: 'TEEN',  minDays: 3,  minWeight: 32 },
  { name: 'BABY',  minDays: 0,  minWeight: 0 }
];

// ============================================================
// SPRITE DATA - Pixel art defined as [x, y] coordinate arrays
// Each coordinate represents one filled pixel
// ============================================================
const SPRITES = {
  blob: {
    baby: {
      frames: [
        // Frame 1
        [
          [2,0],[3,0],
          [1,1],[2,1],[3,1],[4,1],
          [0,2],[1,2],[2,2],[3,2],[4,2],[5,2],
          [0,3],[1,3],[2,3],[3,3],[4,3],[5,3],
          [1,4],[2,4],[3,4],[4,4],
          [2,5],[3,5]
        ],
        // Frame 2 (slightly squished)
        [
          [1,0],[2,0],[3,0],[4,0],
          [0,1],[1,1],[2,1],[3,1],[4,1],[5,1],
          [0,2],[1,2],[2,2],[3,2],[4,2],[5,2],
          [0,3],[1,3],[2,3],[3,3],[4,3],[5,3],
          [1,4],[2,4],[3,4],[4,4],
        ]
      ],
      eyes: [[1,2],[4,2]],
      w: 6, h: 6
    },
    teen: {
      frames: [
        [
          [3,0],[4,0],[5,0],
          [2,1],[3,1],[4,1],[5,1],[6,1],
          [1,2],[2,2],[3,2],[4,2],[5,2],[6,2],[7,2],
          [0,3],[1,3],[2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],
          [0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],
          [1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],
          [2,6],[3,6],[4,6],[5,6],[6,6],
          [3,7],[4,7],[5,7]
        ],
        [
          [3,0],[4,0],[5,0],
          [2,1],[3,1],[4,1],[5,1],[6,1],
          [1,2],[2,2],[3,2],[4,2],[5,2],[6,2],[7,2],
          [0,3],[1,3],[2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],
          [0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],
          [0,5],[1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],
          [2,6],[3,6],[4,6],[5,6],[6,6],
          [3,7],[5,7]
        ]
      ],
      eyes: [[2,3],[6,3]],
      mouth: [[3,5],[4,5],[5,5]],
      w: 9, h: 8
    },
    adult: {
      frames: [
        [
          [4,0],[5,0],[6,0],[7,0],
          [3,1],[4,1],[5,1],[6,1],[7,1],[8,1],
          [2,2],[3,2],[4,2],[5,2],[6,2],[7,2],[8,2],[9,2],
          [1,3],[2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],[9,3],[10,3],
          [0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],[11,4],
          [0,5],[1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],[11,5],
          [0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],
          [1,7],[2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[8,7],[9,7],[10,7],
          [2,8],[3,8],[4,8],[5,8],[6,8],[7,8],[8,8],[9,8],
          [3,9],[4,9],[5,9],[6,9],[7,9],[8,9],
          [4,10],[5,10],[6,10],[7,10],
          // arms
          [-1,4],[-1,5],[12,4],[12,5]
        ],
        [
          [4,0],[5,0],[6,0],[7,0],
          [3,1],[4,1],[5,1],[6,1],[7,1],[8,1],
          [2,2],[3,2],[4,2],[5,2],[6,2],[7,2],[8,2],[9,2],
          [1,3],[2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],[9,3],[10,3],
          [0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],[11,4],
          [0,5],[1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],[11,5],
          [0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],
          [0,7],[1,7],[2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[8,7],[9,7],[10,7],[11,7],
          [2,8],[3,8],[4,8],[5,8],[6,8],[7,8],[8,8],[9,8],
          [4,9],[5,9],[6,9],[7,9],
          // arms up
          [-1,3],[-1,4],[12,3],[12,4]
        ]
      ],
      eyes: [[3,4],[8,4]],
      mouth: [[4,6],[5,6],[6,6],[7,6]],
      w: 13, h: 11
    },
    elder: {
      frames: [
        [
          // crown / horns
          [3,0],[5,0],[7,0],[9,0],[11,0],
          [3,1],[4,1],[5,1],[6,1],[7,1],[8,1],[9,1],[10,1],[11,1],
          // head
          [5,2],[6,2],[7,2],[8,2],[9,2],
          [4,3],[5,3],[6,3],[7,3],[8,3],[9,3],[10,3],
          // body
          [3,4],[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],[11,4],
          [2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],[11,5],[12,5],
          [1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],[12,6],[13,6],
          [0,7],[1,7],[2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[8,7],[9,7],[10,7],[11,7],[12,7],[13,7],[14,7],
          [0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,8],[7,8],[8,8],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],
          [0,9],[1,9],[2,9],[3,9],[4,9],[5,9],[6,9],[7,9],[8,9],[9,9],[10,9],[11,9],[12,9],[13,9],[14,9],
          [1,10],[2,10],[3,10],[4,10],[5,10],[6,10],[7,10],[8,10],[9,10],[10,10],[11,10],[12,10],[13,10],
          [2,11],[3,11],[4,11],[5,11],[6,11],[7,11],[8,11],[9,11],[10,11],[11,11],[12,11],
          [3,12],[4,12],[5,12],[6,12],[7,12],[8,12],[9,12],[10,12],[11,12],
          [5,13],[6,13],[7,13],[8,13],[9,13],
          // arms
          [-1,7],[-1,8],[15,7],[15,8]
        ],
        [
          [3,0],[5,0],[7,0],[9,0],[11,0],
          [3,1],[4,1],[5,1],[6,1],[7,1],[8,1],[9,1],[10,1],[11,1],
          [5,2],[6,2],[7,2],[8,2],[9,2],
          [4,3],[5,3],[6,3],[7,3],[8,3],[9,3],[10,3],
          [3,4],[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],[11,4],
          [2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],[11,5],[12,5],
          [1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],[12,6],[13,6],
          [0,7],[1,7],[2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[8,7],[9,7],[10,7],[11,7],[12,7],[13,7],[14,7],
          [0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,8],[7,8],[8,8],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],
          [0,9],[1,9],[2,9],[3,9],[4,9],[5,9],[6,9],[7,9],[8,9],[9,9],[10,9],[11,9],[12,9],[13,9],[14,9],
          [0,10],[1,10],[2,10],[3,10],[4,10],[5,10],[6,10],[7,10],[8,10],[9,10],[10,10],[11,10],[12,10],[13,10],[14,10],
          [2,11],[3,11],[4,11],[5,11],[6,11],[7,11],[8,11],[9,11],[10,11],[11,11],[12,11],
          [4,12],[5,12],[6,12],[7,12],[8,12],[9,12],[10,12],
          // arms up
          [-1,6],[-1,7],[15,6],[15,7]
        ]
      ],
      eyes: [[4,7],[10,7]],
      mouth: [[6,9],[7,9],[8,9]],
      w: 16, h: 14
    }
  },
  bug: {
    baby: {
      frames: [
        [
          // antennae
          [1,0],[3,0],
          // head
          [1,1],[2,1],[3,1],
          // body
          [0,2],[1,2],[2,2],[3,2],[4,2],
          [1,3],[2,3],[3,3],
          // legs
          [0,3],[4,3]
        ],
        [
          [0,0],[4,0],
          [1,1],[2,1],[3,1],
          [0,2],[1,2],[2,2],[3,2],[4,2],
          [1,3],[2,3],[3,3],
          [0,4],[4,4]
        ]
      ],
      eyes: [[1,1],[3,1]],
      w: 5, h: 5
    },
    teen: {
      frames: [
        [
          // antennae
          [1,0],[6,0],
          [2,1],[5,1],
          // head
          [2,2],[3,2],[4,2],[5,2],
          // body
          [1,3],[2,3],[3,3],[4,3],[5,3],[6,3],
          [1,4],[2,4],[3,4],[4,4],[5,4],[6,4],
          [2,5],[3,5],[4,5],[5,5],
          // legs
          [0,3],[7,3],
          [0,5],[7,5]
        ],
        [
          [0,0],[7,0],
          [1,1],[6,1],
          [2,2],[3,2],[4,2],[5,2],
          [1,3],[2,3],[3,3],[4,3],[5,3],[6,3],
          [1,4],[2,4],[3,4],[4,4],[5,4],[6,4],
          [2,5],[3,5],[4,5],[5,5],
          [0,4],[7,4],
          [0,6],[7,6]
        ]
      ],
      eyes: [[3,2],[4,2]],
      w: 8, h: 7
    },
    adult: {
      frames: [
        [
          // antennae
          [2,0],[9,0],
          [3,1],[8,1],
          // head
          [3,2],[4,2],[5,2],[6,2],[7,2],[8,2],
          // thorax
          [2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],[9,3],
          // abdomen
          [1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],
          [1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],
          [2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],
          [3,7],[4,7],[5,7],[6,7],[7,7],[8,7],
          [4,8],[5,8],[6,8],[7,8],
          // legs
          [0,3],[11,3],
          [0,5],[11,5],
          [1,7],[10,7],
          // wings
          [-1,3],[0,4],[12,3],[11,4]
        ],
        [
          [1,0],[10,0],
          [2,1],[9,1],
          [3,2],[4,2],[5,2],[6,2],[7,2],[8,2],
          [2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],[9,3],
          [1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],
          [1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],
          [2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],
          [3,7],[4,7],[5,7],[6,7],[7,7],[8,7],
          [4,8],[5,8],[6,8],[7,8],
          // legs shifted
          [0,4],[11,4],
          [0,6],[11,6],
          [2,8],[9,8],
          // wings up
          [-1,2],[0,3],[12,2],[11,3]
        ]
      ],
      eyes: [[4,2],[7,2]],
      w: 13, h: 9
    },
    elder: {
      frames: [
        [
          // antennae (longer, branching)
          [2,0],[13,0],
          [3,1],[5,1],[10,1],[12,1],
          [4,2],[6,2],[9,2],[11,2],
          // head
          [5,3],[6,3],[7,3],[8,3],[9,3],[10,3],
          // thorax
          [4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],[11,4],
          [3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],[11,5],[12,5],
          // abdomen
          [2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],[12,6],[13,6],
          [1,7],[2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[8,7],[9,7],[10,7],[11,7],[12,7],[13,7],[14,7],
          [1,8],[2,8],[3,8],[4,8],[5,8],[6,8],[7,8],[8,8],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],
          [2,9],[3,9],[4,9],[5,9],[6,9],[7,9],[8,9],[9,9],[10,9],[11,9],[12,9],[13,9],
          [3,10],[4,10],[5,10],[6,10],[7,10],[8,10],[9,10],[10,10],[11,10],[12,10],
          [5,11],[6,11],[7,11],[8,11],[9,11],[10,11],
          // legs
          [0,5],[15,5],
          [0,7],[15,7],
          [1,9],[14,9],
          // wings
          [-1,4],[0,5],[16,4],[15,5],
          [-1,5],[0,6],[16,5],[15,6]
        ],
        [
          [1,0],[14,0],
          [2,1],[6,1],[9,1],[13,1],
          [3,2],[5,2],[10,2],[12,2],
          [5,3],[6,3],[7,3],[8,3],[9,3],[10,3],
          [4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4],[11,4],
          [3,5],[4,5],[5,5],[6,5],[7,5],[8,5],[9,5],[10,5],[11,5],[12,5],
          [2,6],[3,6],[4,6],[5,6],[6,6],[7,6],[8,6],[9,6],[10,6],[11,6],[12,6],[13,6],
          [1,7],[2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[8,7],[9,7],[10,7],[11,7],[12,7],[13,7],[14,7],
          [1,8],[2,8],[3,8],[4,8],[5,8],[6,8],[7,8],[8,8],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],
          [2,9],[3,9],[4,9],[5,9],[6,9],[7,9],[8,9],[9,9],[10,9],[11,9],[12,9],[13,9],
          [3,10],[4,10],[5,10],[6,10],[7,10],[8,10],[9,10],[10,10],[11,10],[12,10],
          [5,11],[6,11],[7,11],[8,11],[9,11],[10,11],
          // legs shifted
          [0,6],[15,6],
          [0,8],[15,8],
          [2,10],[13,10],
          // wings up
          [-1,3],[0,4],[16,3],[15,4],
          [-1,4],[0,5],[16,4],[15,5]
        ]
      ],
      eyes: [[6,3],[9,3]],
      w: 17, h: 12
    }
  }
};

// Dead sprite overlay (X_X face replacement for eyes)
const DEAD_EYES_PATTERN = {
  // Relative to each eye position: small X pattern
  offsets: [[-1,-1],[1,-1],[-1,1],[1,1],[0,0]]
};

// ============================================================
// STATE
// ============================================================
let pet = null;
let decayTimer = null;
let saveTimer = null;
let spriteFrame = 0;
let spriteTimer = null;
let lastStage = null;
let cooldowns = { feed: 0, play: 0, sleep: 0 };
let cooldownTimers = {};
let audioCtx = null;
let db = null;
let authUser = null;
let livePetSyncTimer = null;
let randomEventTimer = null;
let eventOverlayActive = false;

// ============================================================
// AUDIO - Web Audio API sound effects
// ============================================================
function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioCtx;
}

function playFeedSound() {
  const ctx = getAudioCtx();
  // Two quick "nom nom" square wave blips
  [0, 0.15].forEach((delay, i) => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(200 + i * 80, ctx.currentTime + delay);
    osc.frequency.linearRampToValueAtTime(350 + i * 80, ctx.currentTime + delay + 0.08);
    gain.gain.setValueAtTime(0.15, ctx.currentTime + delay);
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + delay + 0.1);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(ctx.currentTime + delay);
    osc.stop(ctx.currentTime + delay + 0.12);
  });
}

function playPlaySound() {
  const ctx = getAudioCtx();
  // Cheerful ascending arpeggio - 4 triangle wave notes
  const notes = [330, 415, 495, 660];
  notes.forEach((freq, i) => {
    const delay = i * 0.1;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, ctx.currentTime + delay);
    gain.gain.setValueAtTime(0.2, ctx.currentTime + delay);
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + delay + 0.15);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(ctx.currentTime + delay);
    osc.stop(ctx.currentTime + delay + 0.18);
  });
}

function playSleepSound() {
  const ctx = getAudioCtx();
  // Soft descending sine wave sweep
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 1.5);
  gain.gain.setValueAtTime(0.12, ctx.currentTime);
  gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.5);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime + 1.6);
}

function playEventSound(fatal) {
  const ctx = getAudioCtx();
  if (fatal) {
    // Ominous descending buzz
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(300, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(60, ctx.currentTime + 0.8);
    gain.gain.setValueAtTime(0.18, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.9);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 1.0);
  } else {
    // Short alert blip
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'square';
    osc.frequency.setValueAtTime(440, ctx.currentTime);
    osc.frequency.setValueAtTime(520, ctx.currentTime + 0.08);
    osc.frequency.setValueAtTime(440, ctx.currentTime + 0.16);
    gain.gain.setValueAtTime(0.12, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.25);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.3);
  }
}

const ACTION_SOUNDS = { feed: playFeedSound, play: playPlaySound, sleep: playSleepSound };

// ============================================================
// PERSISTENCE
// ============================================================
function savePet() {
  if (!pet) return;
  pet.lastVisit = Date.now();
  localStorage.setItem(SAVE_KEY, JSON.stringify(pet));
}

function loadPet() {
  const data = localStorage.getItem(SAVE_KEY);
  if (!data) return null;
  try { return JSON.parse(data); } catch { return null; }
}

function resetPet() {
  removeLivePet();
  localStorage.removeItem(SAVE_KEY);
  pet = null;
  clearInterval(decayTimer);
  clearInterval(saveTimer);
  clearInterval(spriteTimer);
  clearInterval(livePetSyncTimer);
  clearTimeout(randomEventTimer);
  Object.values(cooldownTimers).forEach(clearInterval);
  showScreen('naming');
}

// ============================================================
// GAME LOGIC
// ============================================================
function createPet() {
  const nameInput = document.getElementById('name-input');
  const name = nameInput.value.trim();
  if (!name) return;

  pet = {
    name: name.toUpperCase(),
    type: Math.random() < 0.5 ? 'blob' : 'bug',
    createdAt: Date.now(),
    lastVisit: Date.now(),
    weight: Math.round((5 + Math.random() * 10) * 10) / 10,
    stats: { hunger: 90, happiness: 90, health: 90, energy: 90 }
  };

  savePet();
  startGame();
}

function startGame() {
  applyAwayDecay();
  lastStage = getStage();
  showScreen('game');
  updateDisplay();
  startSprite();

  decayTimer = setInterval(() => {
    if (getStatus() === 'DEAD') return;
    pet.stats.hunger = Math.max(0, pet.stats.hunger - 1);
    pet.stats.happiness = Math.max(0, pet.stats.happiness - 0.8);
    pet.stats.health = Math.max(0, pet.stats.health - 0.5);
    pet.stats.energy = Math.max(0, pet.stats.energy - 1.2);
    updateDisplay();
    checkDeath();
  }, DECAY_INTERVAL);

  saveTimer = setInterval(savePet, AUTOSAVE_INTERVAL);

  // Sync live pet to Firestore every 60s (and immediately)
  syncLivePet();
  livePetSyncTimer = setInterval(syncLivePet, 60000);

  // Random events — fire one immediately, then at randomised intervals
  triggerRandomEvent();
  scheduleRandomEvent();
}

function applyAwayDecay() {
  if (!pet || !pet.lastVisit) return;
  const elapsed = (Date.now() - pet.lastVisit) / 1000; // seconds
  if (elapsed < 60) return; // ignore if less than a minute

  const decay = elapsed * AWAY_DECAY_RATE;

  for (const stat of Object.keys(pet.stats)) {
    pet.stats[stat] = Math.max(AWAY_STAT_FLOOR, pet.stats[stat] - decay);
  }
  savePet();
}

function doAction(action) {
  if (!pet || getStatus() === 'DEAD') return;
  if (cooldowns[action] > 0) return;

  const effects = ACTION_EFFECTS[action];
  pet.stats.hunger = clamp(pet.stats.hunger + effects.hunger, 0, 100);
  pet.stats.happiness = clamp(pet.stats.happiness + effects.happiness, 0, 100);
  pet.stats.health = clamp(pet.stats.health + effects.health, 0, 100);
  pet.stats.energy = clamp(pet.stats.energy + effects.energy, 0, 100);
  pet.weight = Math.max(1, Math.round((pet.weight + effects.weight) * 10) / 10);

  // Play sound
  ACTION_SOUNDS[action]();

  // Trigger animation
  triggerAnimation(action);

  // Start cooldown
  startCooldown(action);

  savePet();
  updateDisplay();
  checkDeath();
}

function triggerAnimation(action) {
  const sprite = document.getElementById('pet-sprite');
  const area = document.getElementById('pet-area');

  // Remove idle animation during action animation
  sprite.classList.remove('idle-anim');
  sprite.classList.remove('anim-feed', 'anim-play', 'anim-sleep');

  // Force reflow
  void sprite.offsetWidth;

  if (action === 'feed') {
    sprite.classList.add('anim-feed');
    // Spawn food particle
    const food = document.createElement('div');
    food.className = 'food-particle';
    food.style.left = (area.offsetWidth / 2 - 6) + 'px';
    food.style.top = '20px';
    area.appendChild(food);
    setTimeout(() => { food.remove(); }, 1000);
    setTimeout(() => { sprite.classList.remove('anim-feed'); sprite.classList.add('idle-anim'); }, 1000);
  }

  if (action === 'play') {
    sprite.classList.add('anim-play');
    setTimeout(() => { sprite.classList.remove('anim-play'); sprite.classList.add('idle-anim'); }, 1500);
  }

  if (action === 'sleep') {
    sprite.classList.add('anim-sleep');
    setTimeout(() => { sprite.classList.remove('anim-sleep'); sprite.classList.add('idle-anim'); }, 2000);
  }
}

let petClickAnim = null;

function onPetClicked(e) {
  if (!pet || getStatus() === 'DEAD') return;
  const sprite = document.getElementById('pet-sprite');
  const area = document.getElementById('pet-area');
  if (petClickAnim) return;

  // Calculate click position relative to sprite's resting center
  const areaRect = area.getBoundingClientRect();
  const spriteRect = sprite.getBoundingClientRect();
  const spriteCenterX = spriteRect.left + spriteRect.width / 2 - areaRect.left;
  const spriteCenterY = spriteRect.top + spriteRect.height / 2 - areaRect.top;
  const clickX = e.clientX - areaRect.left;
  const clickY = e.clientY - areaRect.top;
  const tx = clickX - spriteCenterX;
  const ty = clickY - spriteCenterY;

  // Perpendicular direction for zigzag
  const dist = Math.sqrt(tx * tx + ty * ty) || 1;
  const px = -ty / dist;
  const py = tx / dist;
  const wobble = Math.min(20, dist * 0.3);

  // Build zigzag keyframes: start → zigzag to target → zigzag back
  const steps = 8;
  const keyframes = [{ transform: 'translate(0px, 0px) rotate(0deg)' }];
  for (let i = 1; i <= steps; i++) {
    const progress = i / steps;
    const x = tx * progress;
    const y = ty * progress;
    const side = (i % 2 === 0 ? 1 : -1) * wobble * (1 - progress * 0.5);
    const rot = side > 0 ? 4 : -4;
    keyframes.push({ transform: `translate(${x + px * side}px, ${y + py * side}px) rotate(${rot}deg)` });
  }
  for (let i = steps - 1; i >= 0; i--) {
    const progress = i / steps;
    const x = tx * progress;
    const y = ty * progress;
    const side = (i % 2 === 0 ? -1 : 1) * wobble * (1 - progress * 0.5);
    const rot = side > 0 ? 4 : -4;
    keyframes.push({ transform: `translate(${x + px * side}px, ${y + py * side}px) rotate(${rot}deg)` });
  }
  keyframes.push({ transform: 'translate(0px, 0px) rotate(0deg)' });

  sprite.classList.remove('idle-anim');
  petClickAnim = sprite.animate(keyframes, { duration: 1500, easing: 'ease-in-out' });
  petClickAnim.onfinish = () => {
    petClickAnim = null;
    sprite.classList.add('idle-anim');
  };
}

function startCooldown(action) {
  const duration = COOLDOWNS[action];
  cooldowns[action] = duration;
  const btn = document.getElementById('btn-' + action);
  const label = action.toUpperCase();

  // Clear existing timer if any
  if (cooldownTimers[action]) clearInterval(cooldownTimers[action]);

  const updateBtn = () => {
    if (cooldowns[action] <= 0) {
      cooldowns[action] = 0;
      btn.disabled = false;
      btn.innerHTML = `[ ${label} ]`;
      clearInterval(cooldownTimers[action]);
      return;
    }
    btn.disabled = true;
    const secs = Math.ceil(cooldowns[action] / 1000);
    btn.innerHTML = `[ ${label} ]<br><span class="cooldown-text">${secs}s</span>`;
  };

  updateBtn();
  cooldownTimers[action] = setInterval(() => {
    cooldowns[action] -= 1000;
    updateBtn();
  }, 1000);
}

function getStatus() {
  if (!pet) return 'DEAD';
  const avg = (pet.stats.hunger + pet.stats.health + pet.stats.energy) / 3;
  for (const t of STATUS_THRESHOLDS) {
    if (avg >= t.min) return t.label;
  }
  return 'DEAD';
}

function getStatusClass() {
  const status = getStatus();
  for (const t of STATUS_THRESHOLDS) {
    if (t.label === status) return t.cls;
  }
  return 'status-dead';
}

function getStage() {
  if (!pet) return 'BABY';
  const days = getDaysAlive();
  for (const stage of EVOLUTION_STAGES) {
    if (days >= stage.minDays || pet.weight >= stage.minWeight) {
      return stage.name;
    }
  }
  return 'BABY';
}

function getDaysAlive() {
  if (!pet) return 0;
  return Math.floor((Date.now() - pet.createdAt) / (1000 * 60 * 60 * 24));
}

function confirmKill() {
  if (!pet || getStatus() === 'DEAD') return;
  document.getElementById('kill-confirm').classList.remove('hidden');
  document.getElementById('kill-confirm').style.display = 'flex';
}

function cancelKill() {
  document.getElementById('kill-confirm').classList.add('hidden');
  document.getElementById('kill-confirm').style.display = 'none';
}

function executeKill() {
  cancelKill();
  pet.stats.hunger = 0;
  pet.stats.happiness = 0;
  pet.stats.health = 0;
  pet.stats.energy = 0;
  updateDisplay();
  checkDeath();
}

function checkDeath() {
  if (getStatus() === 'DEAD') {
    clearInterval(decayTimer);
    clearInterval(saveTimer);
    clearInterval(spriteTimer);
    clearInterval(livePetSyncTimer);
    clearTimeout(randomEventTimer);
    removeLivePet();
    if (!pet.leaderboardSaved) {
      saveToLeaderboard(pet);
      pet.leaderboardSaved = true;
    }
    savePet();
    showDeathScreen();
  }
}

function clamp(val, min, max) {
  return Math.max(min, Math.min(max, val));
}

// ============================================================
// RANDOM EVENTS
// ============================================================
function pickRandomEvent() {
  const totalWeight = RANDOM_EVENTS.reduce((sum, e) => sum + e.weight, 0);
  let roll = Math.random() * totalWeight;
  for (const evt of RANDOM_EVENTS) {
    roll -= evt.weight;
    if (roll <= 0) return evt;
  }
  return RANDOM_EVENTS[0];
}

function scheduleRandomEvent() {
  const delay = RANDOM_EVENT_MIN_DELAY + Math.random() * (RANDOM_EVENT_MAX_DELAY - RANDOM_EVENT_MIN_DELAY);
  randomEventTimer = setTimeout(() => {
    triggerRandomEvent();
    if (pet && getStatus() !== 'DEAD') scheduleRandomEvent();
  }, delay);
}

function triggerRandomEvent() {
  if (!pet || getStatus() === 'DEAD') return;

  const evt = pickRandomEvent();

  if (evt.fatal) {
    showRandomEvent(evt, true);
    // Delay death slightly so the player can read the message
    setTimeout(() => {
      pet.stats.hunger = 0;
      pet.stats.happiness = 0;
      pet.stats.health = 0;
      pet.stats.energy = 0;
      updateDisplay();
      checkDeath();
    }, 1500);
    return;
  }

  // Apply stat effects
  for (const [stat, delta] of Object.entries(evt.effects)) {
    if (pet.stats[stat] !== undefined) {
      pet.stats[stat] = clamp(pet.stats[stat] + delta, 0, 100);
    }
  }

  // Apply weight change
  if (evt.weightDelta) {
    pet.weight = Math.max(1, Math.round((pet.weight + evt.weightDelta) * 10) / 10);
  }

  showRandomEvent(evt, false);
  savePet();
  updateDisplay();
  checkDeath();
}

function showRandomEvent(evt, fatal) {
  playEventSound(fatal);
  const area = document.getElementById('pet-area');
  const overlay = document.createElement('div');
  overlay.className = 'event-overlay' + (fatal ? ' event-fatal' : '');
  overlay.innerHTML = `<div class="event-title">${fatal ? '!! ' : ''}${evt.name}${fatal ? ' !!' : ''}</div><div class="event-msg">${pet.name} ${evt.msg}</div>`;

  // For MADE A FRIEND, render a friend sprite walking the opposite direction
  if (evt.name === 'MADE A FRIEND') {
    const friendEl = document.createElement('div');
    friendEl.className = 'friend-sprite';
    const friendType = pet.type === 'blob' ? 'bug' : 'blob';
    const friendSprite = SPRITES[friendType].baby;
    const frame = friendSprite.frames[0];
    const eyeSet = new Set((friendSprite.eyes || []).map(p => p[0] + ',' + p[1]));
    const shadows = [];
    for (const [x, y] of frame) {
      const c = eyeSet.has(x + ',' + y) ? '#000' : '#33ff33';
      shadows.push(`${x * PIXEL_SIZE}px ${y * PIXEL_SIZE}px 0 0 ${c}`);
    }
    friendEl.style.width = PIXEL_SIZE + 'px';
    friendEl.style.height = PIXEL_SIZE + 'px';
    friendEl.style.boxShadow = shadows.join(', ');
    overlay.appendChild(friendEl);
  }

  area.appendChild(overlay);
  eventOverlayActive = true;
  setTimeout(() => {
    overlay.remove();
    eventOverlayActive = false;
  }, 3500);
}

// ============================================================
// DISPLAY
// ============================================================
function showScreen(screen) {
  document.getElementById('naming-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.add('hidden');
  document.getElementById('game-screen').style.display = 'none';
  document.getElementById('death-screen').classList.add('hidden');
  document.getElementById('death-screen').style.display = 'none';

  if (screen === 'naming') {
    document.getElementById('naming-screen').classList.remove('hidden');
    document.getElementById('naming-screen').style.display = 'flex';
  } else if (screen === 'game') {
    document.getElementById('game-screen').classList.remove('hidden');
    document.getElementById('game-screen').style.display = 'flex';
  } else if (screen === 'death') {
    document.getElementById('death-screen').classList.remove('hidden');
    document.getElementById('death-screen').style.display = 'flex';
  }
}

function updateDisplay() {
  if (!pet) return;

  // Check for evolution (defer if a random event overlay is showing)
  const currentStage = getStage();
  if (lastStage && currentStage !== lastStage && getStatus() !== 'DEAD') {
    if (eventOverlayActive) {
      const pending = currentStage;
      const waitForEvent = setInterval(() => {
        if (!eventOverlayActive) {
          clearInterval(waitForEvent);
          showEvolution(pending);
        }
      }, 200);
    } else {
      showEvolution(currentStage);
    }
  }
  lastStage = currentStage;

  // Info panel
  document.getElementById('pet-name-line').textContent = `${pet.name} the ${pet.type.toUpperCase()}`;
  document.getElementById('stage-display').textContent = `Stage: ${currentStage}`;
  document.getElementById('day-display').textContent = `Day: ${getDaysAlive()}`;
  document.getElementById('weight-display').textContent = `Weight: ${pet.weight.toFixed(1)}g`;
  document.getElementById('type-display').textContent = `Type: ${pet.type.toUpperCase()}`;

  // Status
  const statusEl = document.getElementById('status-display');
  statusEl.textContent = `[ ${getStatus()} ]`;
  statusEl.className = 'status-display ' + getStatusClass();

  // Stat bars
  updateStatBar('hunger', pet.stats.hunger);
  updateStatBar('happiness', pet.stats.happiness);
  updateStatBar('health', pet.stats.health);
  updateStatBar('energy', pet.stats.energy);

  // Update sprite
  renderSprite();
}

function showEvolution(newStage) {
  const area = document.getElementById('pet-area');
  const overlay = document.createElement('div');
  overlay.className = 'evolve-overlay';
  overlay.innerHTML = `<div class="evolve-text">EVOLVED!</div><div class="evolve-stage">${pet.name} is now ${newStage}</div>`;
  area.appendChild(overlay);
  setTimeout(() => overlay.remove(), 3000);
}

function updateStatBar(stat, value) {
  const bar = document.getElementById('bar-' + stat);
  const val = document.getElementById('val-' + stat);
  const blocks = 10;
  const filled = Math.round(value / 10);

  let html = '';
  for (let i = 0; i < blocks; i++) {
    html += `<div class="stat-block ${i < filled ? 'filled' : 'empty'}"></div>`;
  }
  bar.innerHTML = html;
  val.textContent = Math.round(value);
}

// ============================================================
// SPRITE RENDERING
// ============================================================
function renderSprite(dead) {
  if (!pet) return;

  const stage = getStage().toLowerCase();
  const spriteData = SPRITES[pet.type][stage];
  if (!spriteData) return;

  const frame = spriteData.frames[spriteFrame % spriteData.frames.length];
  const container = dead ? document.getElementById('death-sprite') : document.getElementById('pet-sprite');

  // Build box-shadow string
  const shadows = [];
  const color = dead ? '#660000' : '#33ff33';
  const eyeColor = dead ? '#330000' : '#000';

  // Get eyes and mouth positions for this sprite
  const eyeSet = new Set((spriteData.eyes || []).map(p => p[0] + ',' + p[1]));
  const mouthSet = new Set((spriteData.mouth || []).map(p => p[0] + ',' + p[1]));

  for (const [x, y] of frame) {
    const key = x + ',' + y;
    let c = color;
    if (eyeSet.has(key)) {
      if (dead) {
        // Draw X pattern for dead eyes
        c = '#330000';
      } else {
        c = eyeColor;
      }
    } else if (mouthSet.has(key)) {
      c = dead ? '#330000' : '#005500';
    }
    shadows.push(`${x * PIXEL_SIZE}px ${y * PIXEL_SIZE}px 0 0 ${c}`);
  }

  // For dead eyes, add X overlay
  if (dead && spriteData.eyes) {
    for (const [ex, ey] of spriteData.eyes) {
      for (const [dx, dy] of DEAD_EYES_PATTERN.offsets) {
        const nx = ex + dx;
        const ny = ey + dy;
        if (nx >= 0 && ny >= 0) {
          shadows.push(`${nx * PIXEL_SIZE}px ${ny * PIXEL_SIZE}px 0 0 #ff0000`);
        }
      }
    }
  }

  container.style.width = PIXEL_SIZE + 'px';
  container.style.height = PIXEL_SIZE + 'px';
  container.style.boxShadow = shadows.join(', ');
  container.style.marginLeft = ((spriteData.w * PIXEL_SIZE) / 2) + 'px';
  container.style.marginTop = '20px';
  container.style.marginBottom = ((spriteData.h * PIXEL_SIZE) + 20) + 'px';
}

function startSprite() {
  spriteFrame = 0;
  if (spriteTimer) clearInterval(spriteTimer);
  spriteTimer = setInterval(() => {
    spriteFrame = (spriteFrame + 1) % 2;
    if (pet && getStatus() !== 'DEAD') {
      renderSprite();
    }
  }, 800);
}

function showDeathScreen() {
  showScreen('death');
  document.getElementById('death-name').textContent = `${pet.name} the ${pet.type.toUpperCase()}`;
  document.getElementById('death-stats').innerHTML =
    `Lived for ${getDaysAlive()} days<br>` +
    `Final weight: ${pet.weight.toFixed(1)}g<br>` +
    `Stage reached: ${getStage()}`;
  renderSprite(true);
}

// ============================================================
// LEADERBOARD
// ============================================================
function loadLeaderboard() {
  const data = localStorage.getItem(LEADERBOARD_KEY);
  if (!data) return [];
  try { return JSON.parse(data); } catch { return []; }
}

function saveToLeaderboard(petData) {
  const entry = {
    name: petData.name,
    type: petData.type,
    days: Math.floor((Date.now() - petData.createdAt) / (1000 * 60 * 60 * 24)),
    weight: petData.weight,
    stage: getStage(),
    date: Date.now()
  };

  // Always save locally as offline fallback
  const lb = loadLeaderboard();
  lb.push(entry);
  localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(lb));

  // Save to Firestore if available
  if (db && authUser) {
    db.collection('leaderboard').add({
      ...entry,
      uid: authUser.uid,
      date: firebase.firestore.FieldValue.serverTimestamp()
    }).catch(err => {
      console.warn('Failed to save to online leaderboard:', err);
    });
  }
}

function openLeaderboard() {
  const overlay = document.getElementById('leaderboard-overlay');
  overlay.classList.remove('hidden');
  overlay.style.display = 'flex';
  switchLeaderboardTab('days');
}

function closeLeaderboard() {
  const overlay = document.getElementById('leaderboard-overlay');
  overlay.classList.add('hidden');
  overlay.style.display = 'none';
}

function switchLeaderboardTab(sortBy) {
  document.querySelectorAll('.lb-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.sort === sortBy);
  });
  renderLeaderboard(sortBy);
}

function escapeHtml(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

async function renderLeaderboard(sortBy) {
  const list = document.getElementById('leaderboard-list');
  list.innerHTML = '<div class="lb-empty">LOADING...</div>';

  let entries = [];
  let source = 'local';

  try {
    if (db) {
      source = 'online';
      const field = sortBy === 'weight' ? 'weight' : 'days';

      // Fetch live pets and dead pets in parallel
      const [liveSnapshot, deadSnapshot] = await Promise.all([
        db.collection('livePets').orderBy(field, 'desc').limit(8).get(),
        db.collection('leaderboard').orderBy(field, 'desc').limit(8).get()
      ]);

      const liveEntries = liveSnapshot.docs.map(doc => ({ ...doc.data(), alive: true }));
      const deadEntries = deadSnapshot.docs.map(doc => ({ ...doc.data(), alive: false }));
      entries = [...liveEntries, ...deadEntries];
    } else {
      // Offline: use localStorage + local live pet
      entries = loadLeaderboard().map(e => ({ ...e, alive: false }));
      if (pet && getStatus() !== 'DEAD') {
        entries.push({
          name: pet.name, type: pet.type, days: getDaysAlive(),
          weight: pet.weight, stage: getStage(), alive: true
        });
      }
    }
  } catch (err) {
    console.warn('Firestore fetch failed, using local data:', err);
    entries = loadLeaderboard().map(e => ({ ...e, alive: false }));
    if (pet && getStatus() !== 'DEAD') {
      entries.push({
        name: pet.name, type: pet.type, days: getDaysAlive(),
        weight: pet.weight, stage: getStage(), alive: true
      });
    }
  }

  // Sort
  if (sortBy === 'weight') {
    entries.sort((a, b) => b.weight - a.weight);
  } else {
    entries.sort((a, b) => b.days - a.days);
  }

  if (entries.length === 0) {
    list.innerHTML = '<div class="lb-empty">NO RECORDS YET</div>';
    return;
  }

  let html = '<div class="lb-row lb-header">';
  html += '<span class="lb-rank">#</span>';
  html += '<span class="lb-name">NAME</span>';
  html += `<span class="lb-value">${sortBy === 'weight' ? 'WEIGHT' : 'DAYS'}</span>`;
  html += '</div>';

  entries.slice(0, 8).forEach((entry, i) => {
    const isLive = entry.alive;
    const safeName = escapeHtml(entry.name);
    const safeType = entry.type ? escapeHtml(entry.type).toUpperCase() : '';
    html += `<div class="lb-row ${isLive ? 'lb-live' : ''}">`;
    html += `<span class="lb-rank">${i + 1}</span>`;
    html += `<span class="lb-name">${safeName}${safeType ? ' the ' + safeType : ''}`;
    if (isLive) html += ' <span class="lb-live-marker">[ALIVE]</span>';
    else html += ' <span class="lb-dead-marker">[DEAD]</span>';
    html += '</span>';
    if (sortBy === 'weight') {
      html += `<span class="lb-value">${Number(entry.weight).toFixed(1)}g</span>`;
    } else {
      html += `<span class="lb-value">${Math.floor(entry.days)} day${entry.days !== 1 ? 's' : ''}</span>`;
    }
    html += '</div>';
  });

  list.innerHTML = html;
}

// ============================================================
// LIVE PET SYNC
// ============================================================
function syncLivePet() {
  if (!db || !authUser || !pet || getStatus() === 'DEAD') return;
  db.collection('livePets').doc(authUser.uid).set({
    name: pet.name,
    type: pet.type,
    days: getDaysAlive(),
    weight: pet.weight,
    stage: getStage(),
    uid: authUser.uid,
    lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
  }).catch(err => {
    console.warn('Failed to sync live pet:', err);
  });
}

function removeLivePet() {
  if (!db || !authUser) return;
  db.collection('livePets').doc(authUser.uid).delete().catch(err => {
    console.warn('Failed to remove live pet:', err);
  });
}

// ============================================================
// FIREBASE
// ============================================================
function initFirebase() {
  if (FIREBASE_CONFIG.apiKey === 'YOUR_API_KEY') return;
  try {
    firebase.initializeApp(FIREBASE_CONFIG);
    db = firebase.firestore();
    firebase.auth().signInAnonymously().then(cred => {
      authUser = cred.user;
      // Sync live pet now that auth is ready
      syncLivePet();
    }).catch(err => {
      console.warn('Anonymous auth failed:', err);
    });
  } catch (err) {
    console.warn('Firebase init failed:', err);
  }
}

// ============================================================
// INITIALIZATION
// ============================================================
function init() {
  initFirebase();

  const saved = loadPet();
  if (saved) {
    pet = saved;
    if (getStatus() === 'DEAD') {
      showDeathScreen();
    } else {
      startGame();
    }
  } else {
    showScreen('naming');
  }

  // Allow Enter key to submit name
  document.getElementById('name-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') createPet();
  });

  // Click pet to make it wander and jiggle
  document.getElementById('pet-area').addEventListener('click', onPetClicked);
}

init();
</script>
</body>
</html>
